
Step1
-> gnl and save line into structure
-> is_comment 
-> validate room name

Phase 1: number_of_ants
	number_of_ants > 0

Phase 2: the_rooms
	format: name coord_x coord_y
		name:
			cannot start with L or #
			can be unordered
			cannot have the same coord with other room (?)
		coord_x coord_y:
			represented by INT (range: INT_MIN <= coord <= INT_MAX)
Phase 3: the_links
	format: name1-name2
Error:
	empty line
	different phase order
	not enough phases
	##start and ##end happens in other phase than the_rooms
	##start or ##end does not happen at all


Comment starts with #:
	unless:
		##start: modify start room (the line after)
		##end: modify end room (the line after)
Save the line of rooms in structure

Step2
malloc adjacency matrix 



Validation start

# define quatity_of_room

typdef struct s_info{
	int		quantity_of_ants;
	int		quantity_of_rooms; // needed for adjacency matrix 
	char	*name_of_room; // numbering the room but keep name in char array E.g. [0]->room1 [1]->room2
	char	*start_room;
	char	*end_room;
}	t_info;	

typedef struct s_line{
	char *line;
	struct s_line	*s
}	t_line;


# check unique coord:
typedef struct	s_coord {
	int				x;
	int				y;
	char			*room_name; //to check if it's the same room
}				t_coord;
t_coord *coord_array = malloc(sizeof(t_coord) * quantity_of_rooms);
sort then check if there is any repeated coord


---- adjacency matrix ----

Example:

Input:
3
##start
0 1 0
##end
1 5 0
2 9 0
3 13 0
0-2
2-3
3-1

[0]-[2]-[3]-[1]

 | 0  1  2  3
--------------
0| 0  0  8 12
1| 0  0  0  4
2| 8  0  0  4
3| 0 12  4  0

Start -> 0
End -> 1

char or int, do we need to think about distance?

Result:
L1-2
L1-3 L2-2
L1-1 L2-3 L3-2
L2-1 L3-3
L3-1

---- Adjacency List and Adjacency Matrix ---
List: Save memory, take longer to find edge
Metrix: More memory, faster to find the edge
-> Lem in requires the faster solving, so Metrix should be the best case?

Comparison between Adjacency List and Adjacency Matrix representation of Graph
https://www.geeksforgeeks.org/comparison-between-adjacency-list-and-adjacency-matrix-representation-of-graph/

Hashtable:
	https://www.youtube.com/watch?v=KyUTuwz_b7Q&t=1s&ab_channel=ComputerScience
	https://www.youtube.com/watch?v=2Ti5yvumFTU&t=1289s&ab_channel=JacobSorber
	https://cp-algorithms.com/string/string-hashing.html
	
Breadth First Search (BFS):
	https://www.youtube.com/watch?v=pcKY4hjDrxk&t=304&ab_channel=AbdulBari

From STDIN
Phase 1: number_of_ants
Phase 2: the_rooms
Phase 3: the_links

		8	7	5	3	1	
len:6	[d]	[e]	[f]	[b]	[c]	[t]
len:8	[a]	[g]	[h]	[i]	[j]	[k]	[l]	[t]
						6	4	2

[1] path[0] = 6 path[1] = 5 total:10
[2] path[0] = 8 path[1] = 3 total:10


total: 3 | min: 9
len:5	[a][b][p][j][k]
len:5	[a][o][c][q][k]
len:7	[a][f][e][d][m][l][k]
[1] path[0] = 4 path[1] = 6 total:9
[2] path[0] = 4 path[1] = 6 total:9
[3] path[0] = 6 path[1] = 4 total:9

[struct, struct ...]

[1] 1
[2]	2
[3] 1
[4] 2
[5] 1
[6] 2
[7] 1
[8] 1

l1-d l2-a
l1-e l2-g l3-d l4-a
l1-f l2-h 

struc {
	path_number;
	at_which room;
}

while (index < line)
{

}